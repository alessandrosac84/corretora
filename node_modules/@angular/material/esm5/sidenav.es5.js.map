{"version":3,"file":"sidenav.es5.js","sources":["../../../src/lib/sidenav/index.ts","../../../src/lib/sidenav/sidenav-module.ts","../../../src/lib/sidenav/sidenav.ts","../../../src/lib/sidenav/drawer.ts"],"sourcesContent":["/**\n * Generated bundle index. Do not edit.\n */\n\nexport {MatSidenavModule,throwMatDuplicatedDrawerError,MatDrawerToggleResult,MatDrawerContent,MatDrawer,MatDrawerContainer,MatSidenavContent,MatSidenav,MatSidenavContainer} from './public_api';\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {A11yModule} from '@angular/cdk/a11y';\nimport {OverlayModule} from '@angular/cdk/overlay';\nimport {CommonModule} from '@angular/common';\nimport {NgModule} from '@angular/core';\nimport {MatCommonModule} from '@angular/material/core';\nimport {MatDrawer, MatDrawerContainer, MatDrawerContent} from './drawer';\nimport {MatSidenav, MatSidenavContainer, MatSidenavContent} from './sidenav';\nexport class MatSidenavModule {static decorators: DecoratorInvocation[] = [\n{ type: NgModule, args: [{\n  imports: [CommonModule, MatCommonModule, A11yModule, OverlayModule],\n  exports: [\n    MatCommonModule,\n    MatDrawer,\n    MatDrawerContainer,\n    MatDrawerContent,\n    MatSidenav,\n    MatSidenavContainer,\n    MatSidenavContent,\n  ],\n  declarations: [\n    MatDrawer,\n    MatDrawerContainer,\n    MatDrawerContent,\n    MatSidenav,\n    MatSidenavContainer,\n    MatSidenavContent,\n  ],\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction MatSidenavModule_tsickle_Closure_declarations() {\n/** @type {?} */\nMatSidenavModule.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nMatSidenavModule.ctorParameters;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {\n  ChangeDetectionStrategy, ChangeDetectorRef,\n  Component, ContentChild,\n  ContentChildren, forwardRef, Inject, Input,\n  ViewEncapsulation\n} from '@angular/core';\nimport {MatDrawer, MatDrawerContainer, MatDrawerContent} from './drawer';\nimport {animate, state, style, transition, trigger} from '@angular/animations';\nimport {coerceBooleanProperty, coerceNumberProperty} from '@angular/cdk/coercion';\nexport class MatSidenavContent extends MatDrawerContent {\n/**\n * @param {?} changeDetectorRef\n * @param {?} container\n */\nconstructor(\n      changeDetectorRef: ChangeDetectorRef,\n       container: MatSidenavContainer) {\n    super(changeDetectorRef, container);\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Component, args: [{\n  moduleId: module.id,\n  selector: 'mat-sidenav-content',\n  template: '<ng-content></ng-content>',\n  host: {\n    'class': 'mat-drawer-content mat-sidenav-content',\n    '[style.marginLeft.px]': '_margins.left',\n    '[style.marginRight.px]': '_margins.right',\n  },\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  encapsulation: ViewEncapsulation.None,\n  preserveWhitespaces: false,\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ChangeDetectorRef, },\n{type: MatSidenavContainer, decorators: [{ type: Inject, args: [forwardRef(() => MatSidenavContainer), ] }, ]},\n];\n}\n\nfunction MatSidenavContent_tsickle_Closure_declarations() {\n/** @type {?} */\nMatSidenavContent.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nMatSidenavContent.ctorParameters;\n}\n\nexport class MatSidenav extends MatDrawer {\n/**\n * Whether the sidenav is fixed in the viewport.\n * @return {?}\n */\nget fixedInViewport() { return this._fixedInViewport; }\n/**\n * @param {?} value\n * @return {?}\n */\nset fixedInViewport(value) { this._fixedInViewport = coerceBooleanProperty(value); }\nprivate _fixedInViewport = false;\n/**\n * The gap between the top of the sidenav and the top of the viewport when the sidenav is in fixed\n * mode.\n * @return {?}\n */\nget fixedTopGap() { return this._fixedTopGap; }\n/**\n * @param {?} value\n * @return {?}\n */\nset fixedTopGap(value) { this._fixedTopGap = coerceNumberProperty(value); }\nprivate _fixedTopGap = 0;\n/**\n * The gap between the bottom of the sidenav and the bottom of the viewport when the sidenav is in\n * fixed mode.\n * @return {?}\n */\nget fixedBottomGap() { return this._fixedBottomGap; }\n/**\n * @param {?} value\n * @return {?}\n */\nset fixedBottomGap(value) { this._fixedBottomGap = coerceNumberProperty(value); }\nprivate _fixedBottomGap = 0;\nstatic decorators: DecoratorInvocation[] = [\n{ type: Component, args: [{\n  moduleId: module.id,\n  selector: 'mat-sidenav',\n  template: '<ng-content></ng-content>',\n  animations: [\n    trigger('transform', [\n      state('open, open-instant', style({\n        transform: 'translate3d(0, 0, 0)',\n        visibility: 'visible',\n      })),\n      state('void', style({\n        visibility: 'hidden',\n      })),\n      transition('void => open-instant', animate('0ms')),\n      transition('void <=> open, open-instant => void',\n        animate('400ms cubic-bezier(0.25, 0.8, 0.25, 1)'))\n    ])\n  ],\n  host: {\n    'class': 'mat-drawer mat-sidenav',\n    'tabIndex': '-1',\n    '[@transform]': '_animationState',\n    '(@transform.start)': '_onAnimationStart()',\n    '(@transform.done)': '_onAnimationEnd($event)',\n    '(keydown)': 'handleKeydown($event)',\n    // must prevent the browser from aligning text based on value\n    '[attr.align]': 'null',\n    '[class.mat-drawer-end]': 'position === \"end\"',\n    '[class.mat-drawer-over]': 'mode === \"over\"',\n    '[class.mat-drawer-push]': 'mode === \"push\"',\n    '[class.mat-drawer-side]': 'mode === \"side\"',\n    '[class.mat-sidenav-fixed]': 'fixedInViewport',\n    '[style.top.px]': 'fixedInViewport ? fixedTopGap : null',\n    '[style.bottom.px]': 'fixedInViewport ? fixedBottomGap : null',\n  },\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  encapsulation: ViewEncapsulation.None,\n  preserveWhitespaces: false,\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'fixedInViewport': [{ type: Input },],\n'fixedTopGap': [{ type: Input },],\n'fixedBottomGap': [{ type: Input },],\n};\n}\n\nfunction MatSidenav_tsickle_Closure_declarations() {\n/** @type {?} */\nMatSidenav.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nMatSidenav.ctorParameters;\n/** @type {?} */\nMatSidenav.propDecorators;\n/** @type {?} */\nMatSidenav.prototype._fixedInViewport;\n/** @type {?} */\nMatSidenav.prototype._fixedTopGap;\n/** @type {?} */\nMatSidenav.prototype._fixedBottomGap;\n}\n\nexport class MatSidenavContainer extends MatDrawerContainer {\n   _drawers;\n\n   _content;\nstatic decorators: DecoratorInvocation[] = [\n{ type: Component, args: [{\n  moduleId: module.id,\n  selector: 'mat-sidenav-container',\n  templateUrl: 'sidenav-container.html',\n  styleUrls: [\n    'drawer.css',\n    'drawer-transitions.css',\n  ],\n  host: {\n    'class': 'mat-drawer-container mat-sidenav-container',\n  },\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  encapsulation: ViewEncapsulation.None,\n  preserveWhitespaces: false,\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'_drawers': [{ type: ContentChildren, args: [MatSidenav, ] },],\n'_content': [{ type: ContentChild, args: [MatSidenavContent, ] },],\n};\n}\n\nfunction MatSidenavContainer_tsickle_Closure_declarations() {\n/** @type {?} */\nMatSidenavContainer.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nMatSidenavContainer.ctorParameters;\n/** @type {?} */\nMatSidenavContainer.propDecorators;\n/** @type {?} */\nMatSidenavContainer.prototype._drawers;\n/** @type {?} */\nMatSidenavContainer.prototype._content;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {animate, AnimationEvent, state, style, transition, trigger} from '@angular/animations';\nimport {FocusTrap, FocusTrapFactory} from '@angular/cdk/a11y';\nimport {Directionality} from '@angular/cdk/bidi';\nimport {coerceBooleanProperty} from '@angular/cdk/coercion';\nimport {ESCAPE} from '@angular/cdk/keycodes';\nimport {\n  AfterContentInit,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  ContentChild,\n  ContentChildren,\n  ElementRef,\n  EventEmitter,\n  forwardRef,\n  Inject,\n  Input,\n  NgZone,\n  OnDestroy,\n  Optional,\n  Output,\n  QueryList,\n  Renderer2,\n  ViewEncapsulation,\n} from '@angular/core';\nimport {DOCUMENT} from '@angular/platform-browser';\nimport {merge} from 'rxjs/observable/merge';\nimport {first} from 'rxjs/operator/first';\nimport {startWith} from 'rxjs/operator/startWith';\nimport {takeUntil} from 'rxjs/operator/takeUntil';\nimport {Subject} from 'rxjs/Subject';\nimport {Subscription} from 'rxjs/Subscription';\n/**\n * Throws an exception when two MatDrawer are matching the same position.\n * @param {?} position\n * @return {?}\n */\nexport function throwMatDuplicatedDrawerError(position: string) {\n  throw Error(`A drawer was already declared for 'position=\"${position}\"'`);\n}\n/**\n * Drawer toggle promise result.\n * @deprecated\n */\nexport class MatDrawerToggleResult {\n/**\n * @param {?} type\n * @param {?} animationFinished\n */\nconstructor(public type: 'open' | 'close',\npublic animationFinished: boolean) {}\n}\n\nfunction MatDrawerToggleResult_tsickle_Closure_declarations() {\n/** @type {?} */\nMatDrawerToggleResult.prototype.type;\n/** @type {?} */\nMatDrawerToggleResult.prototype.animationFinished;\n}\n\nexport class MatDrawerContent implements AfterContentInit {\n/**\n * Margins to be applied to the content. These are used to push / shrink the drawer content when a\n * drawer is open. We use margin rather than transform even for push mode because transform breaks\n * fixed position elements inside of the transformed element.\n */\n_margins: {left: number, right: number} = {left: 0, right: 0};\n/**\n * @param {?} _changeDetectorRef\n * @param {?} _container\n */\nconstructor(\nprivate _changeDetectorRef: ChangeDetectorRef,\nprivate _container: MatDrawerContainer) {\n  }\n/**\n * @return {?}\n */\nngAfterContentInit() {\n    this._container._contentMargins.subscribe(margins => {\n      this._margins = margins;\n      this._changeDetectorRef.markForCheck();\n    });\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Component, args: [{\n  moduleId: module.id,\n  selector: 'mat-drawer-content',\n  template: '<ng-content></ng-content>',\n  host: {\n    'class': 'mat-drawer-content',\n    '[style.marginLeft.px]': '_margins.left',\n    '[style.marginRight.px]': '_margins.right',\n  },\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  encapsulation: ViewEncapsulation.None,\n  preserveWhitespaces: false,\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ChangeDetectorRef, },\n{type: MatDrawerContainer, decorators: [{ type: Inject, args: [forwardRef(() => MatDrawerContainer), ] }, ]},\n];\n}\n\nfunction MatDrawerContent_tsickle_Closure_declarations() {\n/** @type {?} */\nMatDrawerContent.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nMatDrawerContent.ctorParameters;\n/**\n * Margins to be applied to the content. These are used to push / shrink the drawer content when a\n * drawer is open. We use margin rather than transform even for push mode because transform breaks\n * fixed position elements inside of the transformed element.\n * @type {?}\n */\nMatDrawerContent.prototype._margins;\n/** @type {?} */\nMatDrawerContent.prototype._changeDetectorRef;\n/** @type {?} */\nMatDrawerContent.prototype._container;\n}\n\n/**\n * <mat-drawer> component.\n * \n * This component corresponds to a drawer that can be opened on the drawer container.\n * \n * Please refer to README.md for examples on how to use it.\n */\nexport class MatDrawer implements AfterContentInit, OnDestroy {\nprivate _focusTrap: FocusTrap;\nprivate _elementFocusedBeforeDrawerWasOpened: HTMLElement | null = null;\n/**\n * Whether the drawer is initialized. Used for disabling the initial animation.\n */\nprivate _enableAnimations = false;\n/**\n * The side that the drawer is attached to.\n * @return {?}\n */\nget position() { return this._position; }\n/**\n * @param {?} value\n * @return {?}\n */\nset position(value) {\n    // Make sure we have a valid value.\n    value = value === 'end' ? 'end' : 'start';\n    if (value != this._position) {\n      this._position = value;\n      this.onAlignChanged.emit();\n      this.onPositionChanged.emit();\n    }\n  }\nprivate _position: 'start' | 'end' = 'start';\n/**\n * @deprecated\n * @return {?}\n */\nget align() { return this.position; }\n/**\n * @param {?} value\n * @return {?}\n */\nset align(value) { this.position = value; }\n/**\n * Mode of the drawer; one of 'over', 'push' or 'side'.\n * @return {?}\n */\nget mode() { return this._mode; }\n/**\n * @param {?} value\n * @return {?}\n */\nset mode(value) {\n    this._mode = value;\n    this._modeChanged.next();\n  }\nprivate _mode: 'over' | 'push' | 'side' = 'over';\n/**\n * Whether the drawer can be closed with the escape key or by clicking on the backdrop.\n * @return {?}\n */\nget disableClose(): boolean { return this._disableClose; }\n/**\n * @param {?} value\n * @return {?}\n */\nset disableClose(value: boolean) { this._disableClose = coerceBooleanProperty(value); }\nprivate _disableClose: boolean = false;\n/**\n * Whether the drawer is opened.\n */\nprivate _opened: boolean = false;\n/**\n * Emits whenever the drawer has started animating.\n */\n_animationStarted = new EventEmitter<void>();\n/**\n * Whether the drawer is animating. Used to prevent overlapping animations.\n */\n_isAnimating = false;\n/**\n * Current state of the sidenav animation.\n */\n_animationState: 'open-instant' | 'open' | 'void' = 'void';\n/**\n * Promise that resolves when the open/close animation completes. It is here for backwards\n * compatibility and should be removed next time we do drawer breaking changes.\n * @deprecated\n */\nprivate _currentTogglePromise: Promise<MatDrawerToggleResult> | null;\n/**\n * Event emitted when the drawer is fully opened.\n */\nonOpen = new EventEmitter<MatDrawerToggleResult | void>();\n/**\n * Event emitted when the drawer is fully closed.\n */\nonClose = new EventEmitter<MatDrawerToggleResult | void>();\n/**\n * Event emitted when the drawer's position changes.\n */\nonPositionChanged = new EventEmitter<void>();\n/**\n * @deprecated\n */\nonAlignChanged = new EventEmitter<void>();\n/**\n * An observable that emits when the drawer mode changes. This is used by the drawer container to\n * to know when to when the mode changes so it can adapt the margins on the content.\n */\n_modeChanged = new Subject();\n/**\n * @return {?}\n */\nget isFocusTrapEnabled() {\n    // The focus trap is only enabled when the drawer is open in any mode other than side.\n    return this.opened && this.mode !== 'side';\n  }\n/**\n * @param {?} _elementRef\n * @param {?} _focusTrapFactory\n * @param {?} _doc\n */\nconstructor(private _elementRef: ElementRef,\nprivate _focusTrapFactory: FocusTrapFactory,\nprivate _doc: any) {\n    this.onOpen.subscribe(() => {\n      if (this._doc) {\n        this._elementFocusedBeforeDrawerWasOpened = this._doc.activeElement as HTMLElement;\n      }\n\n      if (this.isFocusTrapEnabled && this._focusTrap) {\n        this._focusTrap.focusInitialElementWhenReady();\n      }\n    });\n\n    this.onClose.subscribe(() => this._restoreFocus());\n  }\n/**\n * If focus is currently inside the drawer, restores it to where it was before the drawer\n * opened.\n * @return {?}\n */\nprivate _restoreFocus() {\n    let /** @type {?} */ activeEl = this._doc && this._doc.activeElement;\n    if (activeEl && this._elementRef.nativeElement.contains(activeEl)) {\n      if (this._elementFocusedBeforeDrawerWasOpened instanceof HTMLElement) {\n        this._elementFocusedBeforeDrawerWasOpened.focus();\n      } else {\n        this._elementRef.nativeElement.blur();\n      }\n    }\n\n    this._elementFocusedBeforeDrawerWasOpened = null;\n  }\n/**\n * @return {?}\n */\nngAfterContentInit() {\n    this._focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement);\n    this._focusTrap.enabled = this.isFocusTrapEnabled;\n    this._enableAnimations = true;\n  }\n/**\n * @return {?}\n */\nngOnDestroy() {\n    if (this._focusTrap) {\n      this._focusTrap.destroy();\n    }\n  }\n/**\n * Whether the drawer is opened. We overload this because we trigger an event when it\n * starts or end.\n * @return {?}\n */\nget opened(): boolean { return this._opened; }\n/**\n * @param {?} v\n * @return {?}\n */\nset opened(v: boolean) {\n    this.toggle(coerceBooleanProperty(v));\n  }\n/**\n * Open the drawer.\n * @return {?}\n */\nopen(): Promise<MatDrawerToggleResult> {\n    return this.toggle(true);\n  }\n/**\n * Close the drawer.\n * @return {?}\n */\nclose(): Promise<MatDrawerToggleResult> {\n    return this.toggle(false);\n  }\n/**\n * Toggle this drawer.\n * @param {?=} isOpen Whether the drawer should be open.\n * @return {?}\n */\ntoggle(isOpen: boolean = !this.opened): Promise<MatDrawerToggleResult> {\n    if (!this._isAnimating) {\n      this._opened = isOpen;\n\n      if (isOpen) {\n        this._animationState = this._enableAnimations ? 'open' : 'open-instant';\n      } else {\n        this._animationState = 'void';\n      }\n\n      this._currentTogglePromise = new Promise(resolve => {\n        first.call(isOpen ? this.onOpen : this.onClose).subscribe(resolve);\n      });\n\n      if (this._focusTrap) {\n        this._focusTrap.enabled = this.isFocusTrapEnabled;\n      }\n    }\n\n    // TODO(crisbeto): This promise is here for backwards-compatibility.\n    // It should be removed next time we do breaking changes in the drawer.\n    return /** @type {?} */(( this._currentTogglePromise));\n  }\n/**\n * Handles the keyboard events.\n * \\@docs-private\n * @param {?} event\n * @return {?}\n */\nhandleKeydown(event: KeyboardEvent) {\n    if (event.keyCode === ESCAPE && !this.disableClose) {\n      this.close();\n      event.stopPropagation();\n    }\n  }\n/**\n * @return {?}\n */\n_onAnimationStart() {\n    this._isAnimating = true;\n    this._animationStarted.emit();\n  }\n/**\n * @param {?} event\n * @return {?}\n */\n_onAnimationEnd(event: AnimationEvent) {\n    const {fromState, toState} = event;\n\n    if (toState === 'open' && fromState === 'void') {\n      this.onOpen.emit(new MatDrawerToggleResult('open', true));\n    } else if (toState === 'void' && fromState === 'open') {\n      this.onClose.emit(new MatDrawerToggleResult('close', true));\n    }\n\n    // Note: as of Angular 4.3, the animations module seems to fire the `start` callback before\n    // the end if animations are disabled. Make this call async to ensure that it still fires\n    // at the appropriate time.\n    Promise.resolve().then(() => {\n      this._isAnimating = false;\n      this._currentTogglePromise = null;\n    });\n  }\n/**\n * @return {?}\n */\nget _width() {\n    return this._elementRef.nativeElement ? (this._elementRef.nativeElement.offsetWidth || 0) : 0;\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Component, args: [{\n  moduleId: module.id,\n  selector: 'mat-drawer',\n  template: '<ng-content></ng-content>',\n  animations: [\n    trigger('transform', [\n      state('open, open-instant', style({\n        transform: 'translate3d(0, 0, 0)',\n        visibility: 'visible',\n      })),\n      state('void', style({\n        visibility: 'hidden',\n      })),\n      transition('void => open-instant', animate('0ms')),\n      transition('void <=> open, open-instant => void',\n          animate('400ms cubic-bezier(0.25, 0.8, 0.25, 1)'))\n    ])\n  ],\n  host: {\n    'class': 'mat-drawer',\n    '[@transform]': '_animationState',\n    '(@transform.start)': '_onAnimationStart()',\n    '(@transform.done)': '_onAnimationEnd($event)',\n    '(keydown)': 'handleKeydown($event)',\n    // must prevent the browser from aligning text based on value\n    '[attr.align]': 'null',\n    '[class.mat-drawer-end]': 'position === \"end\"',\n    '[class.mat-drawer-over]': 'mode === \"over\"',\n    '[class.mat-drawer-push]': 'mode === \"push\"',\n    '[class.mat-drawer-side]': 'mode === \"side\"',\n    'tabIndex': '-1',\n  },\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  encapsulation: ViewEncapsulation.None,\n  preserveWhitespaces: false,\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ElementRef, },\n{type: FocusTrapFactory, },\n{type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT, ] }, ]},\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'position': [{ type: Input },],\n'align': [{ type: Input },],\n'mode': [{ type: Input },],\n'disableClose': [{ type: Input },],\n'onOpen': [{ type: Output, args: ['open', ] },],\n'onClose': [{ type: Output, args: ['close', ] },],\n'onPositionChanged': [{ type: Output, args: ['positionChanged', ] },],\n'onAlignChanged': [{ type: Output, args: ['align-changed', ] },],\n'opened': [{ type: Input },],\n};\n}\n\nfunction MatDrawer_tsickle_Closure_declarations() {\n/** @type {?} */\nMatDrawer.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nMatDrawer.ctorParameters;\n/** @type {?} */\nMatDrawer.propDecorators;\n/** @type {?} */\nMatDrawer.prototype._focusTrap;\n/** @type {?} */\nMatDrawer.prototype._elementFocusedBeforeDrawerWasOpened;\n/**\n * Whether the drawer is initialized. Used for disabling the initial animation.\n * @type {?}\n */\nMatDrawer.prototype._enableAnimations;\n/** @type {?} */\nMatDrawer.prototype._position;\n/** @type {?} */\nMatDrawer.prototype._mode;\n/** @type {?} */\nMatDrawer.prototype._disableClose;\n/**\n * Whether the drawer is opened.\n * @type {?}\n */\nMatDrawer.prototype._opened;\n/**\n * Emits whenever the drawer has started animating.\n * @type {?}\n */\nMatDrawer.prototype._animationStarted;\n/**\n * Whether the drawer is animating. Used to prevent overlapping animations.\n * @type {?}\n */\nMatDrawer.prototype._isAnimating;\n/**\n * Current state of the sidenav animation.\n * @type {?}\n */\nMatDrawer.prototype._animationState;\n/**\n * Promise that resolves when the open/close animation completes. It is here for backwards\n * compatibility and should be removed next time we do drawer breaking changes.\n * @deprecated\n * @type {?}\n */\nMatDrawer.prototype._currentTogglePromise;\n/**\n * Event emitted when the drawer is fully opened.\n * @type {?}\n */\nMatDrawer.prototype.onOpen;\n/**\n * Event emitted when the drawer is fully closed.\n * @type {?}\n */\nMatDrawer.prototype.onClose;\n/**\n * Event emitted when the drawer's position changes.\n * @type {?}\n */\nMatDrawer.prototype.onPositionChanged;\n/**\n * @deprecated\n * @type {?}\n */\nMatDrawer.prototype.onAlignChanged;\n/**\n * An observable that emits when the drawer mode changes. This is used by the drawer container to\n * to know when to when the mode changes so it can adapt the margins on the content.\n * @type {?}\n */\nMatDrawer.prototype._modeChanged;\n/** @type {?} */\nMatDrawer.prototype._elementRef;\n/** @type {?} */\nMatDrawer.prototype._focusTrapFactory;\n/** @type {?} */\nMatDrawer.prototype._doc;\n}\n\n/**\n * <mat-drawer-container> component.\n * \n * This is the parent component to one or two <mat-drawer>s that validates the state internally\n * and coordinates the backdrop and content styling.\n */\nexport class MatDrawerContainer implements AfterContentInit, OnDestroy {\n   _drawers: QueryList<MatDrawer>;\n\n   _content: MatDrawerContent;\n/**\n * The drawer child with the `start` position.\n * @return {?}\n */\nget start() { return this._start; }\n/**\n * The drawer child with the `end` position.\n * @return {?}\n */\nget end() { return this._end; }\n/**\n * Event emitted when the drawer backdrop is clicked.\n */\nbackdropClick = new EventEmitter<void>();\n/**\n * The drawer at the start/end position, independent of direction.\n */\nprivate _start: MatDrawer | null;\nprivate _end: MatDrawer | null;\n/**\n * The drawer at the left/right. When direction changes, these will change as well.\n * They're used as aliases for the above to set the left/right style properly.\n * In LTR, _left == _start and _right == _end.\n * In RTL, _left == _end and _right == _start.\n */\nprivate _left: MatDrawer | null;\nprivate _right: MatDrawer | null;\n/**\n * Subscription to the Directionality change EventEmitter.\n */\nprivate _dirChangeSubscription = Subscription.EMPTY;\n\n  _contentMargins = new Subject<{left: number, right: number}>();\n/**\n * @param {?} _dir\n * @param {?} _element\n * @param {?} _renderer\n * @param {?} _ngZone\n * @param {?} _changeDetectorRef\n */\nconstructor(\nprivate _dir: Directionality,\nprivate _element: ElementRef,\nprivate _renderer: Renderer2,\nprivate _ngZone: NgZone,\nprivate _changeDetectorRef: ChangeDetectorRef) {\n    // If a `Dir` directive exists up the tree, listen direction changes and update the left/right\n    // properties to point to the proper start/end.\n    if (_dir != null) {\n      this._dirChangeSubscription = _dir.change.subscribe(() => this._validateDrawers());\n    }\n  }\n/**\n * @return {?}\n */\nngAfterContentInit() {\n    startWith.call(this._drawers.changes, null).subscribe(() => {\n      this._validateDrawers();\n      this._drawers.forEach((drawer: MatDrawer) => {\n        this._watchDrawerToggle(drawer);\n        this._watchDrawerPosition(drawer);\n        this._watchDrawerMode(drawer);\n      });\n    });\n  }\n/**\n * @return {?}\n */\nngOnDestroy() {\n    this._dirChangeSubscription.unsubscribe();\n  }\n/**\n * Calls `open` of both start and end drawers\n * @return {?}\n */\nopen(): void {\n    this._drawers.forEach(drawer => drawer.open());\n  }\n/**\n * Calls `close` of both start and end drawers\n * @return {?}\n */\nclose(): void {\n    this._drawers.forEach(drawer => drawer.close());\n  }\n/**\n * Subscribes to drawer events in order to set a class on the main container element when the\n * drawer is open and the backdrop is visible. This ensures any overflow on the container element\n * is properly hidden.\n * @param {?} drawer\n * @return {?}\n */\nprivate _watchDrawerToggle(drawer: MatDrawer): void {\n    takeUntil.call(drawer._animationStarted, this._drawers.changes).subscribe(() => {\n      // Set the transition class on the container so that the animations occur. This should not\n      // be set initially because animations should only be triggered via a change in state.\n      this._renderer.addClass(this._element.nativeElement, 'mat-drawer-transition');\n      this._updateContentMargins();\n      this._changeDetectorRef.markForCheck();\n    });\n\n    if (drawer.mode !== 'side') {\n      takeUntil.call(merge(drawer.onOpen, drawer.onClose), this._drawers.changes).subscribe(() =>\n          this._setContainerClass(drawer.opened));\n    }\n  }\n/**\n * Subscribes to drawer onPositionChanged event in order to re-validate drawers when the position\n * changes.\n * @param {?} drawer\n * @return {?}\n */\nprivate _watchDrawerPosition(drawer: MatDrawer): void {\n    if (!drawer) {\n      return;\n    }\n    // NOTE: We need to wait for the microtask queue to be empty before validating,\n    // since both drawers may be swapping positions at the same time.\n    takeUntil.call(drawer.onPositionChanged, this._drawers.changes).subscribe(() => {\n      first.call(this._ngZone.onMicrotaskEmpty.asObservable()).subscribe(() => {\n        this._validateDrawers();\n      });\n    });\n  }\n/**\n * Subscribes to changes in drawer mode so we can run change detection.\n * @param {?} drawer\n * @return {?}\n */\nprivate _watchDrawerMode(drawer: MatDrawer): void {\n    if (drawer) {\n      takeUntil.call(drawer._modeChanged, this._drawers.changes).subscribe(() => {\n        this._updateContentMargins();\n        this._changeDetectorRef.markForCheck();\n      });\n    }\n  }\n/**\n * Toggles the 'mat-drawer-opened' class on the main 'mat-drawer-container' element.\n * @param {?} isAdd\n * @return {?}\n */\nprivate _setContainerClass(isAdd: boolean): void {\n    if (isAdd) {\n      this._renderer.addClass(this._element.nativeElement, 'mat-drawer-opened');\n    } else {\n      this._renderer.removeClass(this._element.nativeElement, 'mat-drawer-opened');\n    }\n  }\n/**\n * Validate the state of the drawer children components.\n * @return {?}\n */\nprivate _validateDrawers() {\n    this._start = this._end = null;\n\n    // Ensure that we have at most one start and one end drawer.\n    this._drawers.forEach(drawer => {\n      if (drawer.position == 'end') {\n        if (this._end != null) {\n          throwMatDuplicatedDrawerError('end');\n        }\n        this._end = drawer;\n      } else {\n        if (this._start != null) {\n          throwMatDuplicatedDrawerError('start');\n        }\n        this._start = drawer;\n      }\n    });\n\n    this._right = this._left = null;\n\n    // Detect if we're LTR or RTL.\n    if (this._dir == null || this._dir.value == 'ltr') {\n      this._left = this._start;\n      this._right = this._end;\n    } else {\n      this._left = this._end;\n      this._right = this._start;\n    }\n  }\n/**\n * @return {?}\n */\n_onBackdropClicked() {\n    this.backdropClick.emit();\n    this._closeModalDrawer();\n  }\n/**\n * @return {?}\n */\n_closeModalDrawer() {\n    // Close all open drawers where closing is not disabled and the mode is not `side`.\n    [this._start, this._end]\n      .filter(drawer => drawer && !drawer.disableClose && drawer.mode !== 'side')\n      .forEach(drawer => /** @type {?} */(( drawer)).close());\n  }\n/**\n * @return {?}\n */\n_isShowingBackdrop(): boolean {\n    return (this._isDrawerOpen(this._start) && /** @type {?} */(( this._start)).mode != 'side')\n        || (this._isDrawerOpen(this._end) && /** @type {?} */(( this._end)).mode != 'side');\n  }\n/**\n * @param {?} drawer\n * @return {?}\n */\nprivate _isDrawerOpen(drawer: MatDrawer | null): boolean {\n    return drawer != null && drawer.opened;\n  }\n/**\n * Recalculates and updates the inline styles for the content. Note that this should be used\n * sparingly, because it causes a reflow.\n * @return {?}\n */\nprivate _updateContentMargins() {\n    // 1. For drawers in `over` mode, they don't affect the content.\n    // 2. For drawers in `side` mode they should shrink the content. We do this by adding to the\n    //    left margin (for left drawer) or right margin (for right the drawer).\n    // 3. For drawers in `push` mode the should shift the content without resizing it. We do this by\n    //    adding to the left or right margin and simultaneously subtracting the same amount of\n    //    margin from the other side.\n\n    let /** @type {?} */ left = 0;\n    let /** @type {?} */ right = 0;\n\n    if (this._left && this._left.opened) {\n      if (this._left.mode == 'side') {\n        left += this._left._width;\n      } else if (this._left.mode == 'push') {\n        let /** @type {?} */ width = this._left._width;\n        left += width;\n        right -= width;\n      }\n    }\n\n    if (this._right && this._right.opened) {\n      if (this._right.mode == 'side') {\n        right += this._right._width;\n      } else if (this._right.mode == 'push') {\n        let /** @type {?} */ width = this._right._width;\n        right += width;\n        left -= width;\n      }\n    }\n\n    this._contentMargins.next({left, right});\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Component, args: [{\n  moduleId: module.id,\n  selector: 'mat-drawer-container',\n  templateUrl: 'drawer-container.html',\n  styleUrls: [\n    'drawer.css',\n    'drawer-transitions.css',\n  ],\n  host: {\n    'class': 'mat-drawer-container',\n  },\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  encapsulation: ViewEncapsulation.None,\n  preserveWhitespaces: false,\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: Directionality, decorators: [{ type: Optional }, ]},\n{type: ElementRef, },\n{type: Renderer2, },\n{type: NgZone, },\n{type: ChangeDetectorRef, },\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'_drawers': [{ type: ContentChildren, args: [MatDrawer, ] },],\n'_content': [{ type: ContentChild, args: [MatDrawerContent, ] },],\n'backdropClick': [{ type: Output },],\n};\n}\n\nfunction MatDrawerContainer_tsickle_Closure_declarations() {\n/** @type {?} */\nMatDrawerContainer.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nMatDrawerContainer.ctorParameters;\n/** @type {?} */\nMatDrawerContainer.propDecorators;\n/** @type {?} */\nMatDrawerContainer.prototype._drawers;\n/** @type {?} */\nMatDrawerContainer.prototype._content;\n/**\n * Event emitted when the drawer backdrop is clicked.\n * @type {?}\n */\nMatDrawerContainer.prototype.backdropClick;\n/**\n * The drawer at the start/end position, independent of direction.\n * @type {?}\n */\nMatDrawerContainer.prototype._start;\n/** @type {?} */\nMatDrawerContainer.prototype._end;\n/**\n * The drawer at the left/right. When direction changes, these will change as well.\n * They're used as aliases for the above to set the left/right style properly.\n * In LTR, _left == _start and _right == _end.\n * In RTL, _left == _end and _right == _start.\n * @type {?}\n */\nMatDrawerContainer.prototype._left;\n/** @type {?} */\nMatDrawerContainer.prototype._right;\n/**\n * Subscription to the Directionality change EventEmitter.\n * @type {?}\n */\nMatDrawerContainer.prototype._dirChangeSubscription;\n/** @type {?} */\nMatDrawerContainer.prototype._contentMargins;\n/** @type {?} */\nMatDrawerContainer.prototype._dir;\n/** @type {?} */\nMatDrawerContainer.prototype._element;\n/** @type {?} */\nMatDrawerContainer.prototype._renderer;\n/** @type {?} */\nMatDrawerContainer.prototype._ngZone;\n/** @type {?} */\nMatDrawerContainer.prototype._changeDetectorRef;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"],"names":[],"mappings":"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"}